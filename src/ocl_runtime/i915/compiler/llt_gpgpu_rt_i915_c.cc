#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <stdexcept>
#include <system_error>
#include <map>
#include <vector>
#include "igc_interface.h"
#include "offline_device_info.h"
#include "translate_interfaces.h"
#include "llt_gpgpu_rt_config.h"
#include "../utils.h"

using namespace std;


struct Args
{
	string input_filename;
	string output_filename;
	string cl_standard;

	void print_help()
	{
		fprintf(stderr,
				"Offline compiler of LLT GPGPU Runtime Version %d.%d.%d\n\n"

				"Usage: llt_gpgpu_rt_i915_c [options] <input filename>\n\n"

				"Options:\n"
				"    -o <output filename>\n"
				"    -cl-std=<OpenCL standard>  Currently only CL1.2 is supported\n"
				"    --help\n\n",
				LLT_GPGPU_RT_VERSION_MAJOR, LLT_GPGPU_RT_VERSION_MINOR,
				LLT_GPGPU_RT_VERSION_PATCH);
	}

	bool parse(int argc, char** argv)
	{
		bool have_input_filename = false;
		bool have_output_filename = false;
		bool have_cl_standard = false;

		for (int i = 1; i < argc; i++)
		{
			auto arg = argv[i];

			if (strlen(arg) > 1 && arg[0] == '-')
			{
				if (strcmp(arg, "-o") == 0)
				{
					if (have_output_filename)
					{
						fprintf(stderr, "-o may only be specified once\n");
						return false;
					}

					if (++i >= argc)
					{
						fprintf(stderr, "-o expects an argument\n");
						return false;
					}

					output_filename = argv[i];
					have_output_filename = true;
				}
				else if (strcmp(arg, "-cl-std=CL1.2") == 0)
				{
					if (have_cl_standard)
					{
						fprintf(stderr, "-cl-std may only be specified once\n");
						return false;
					}

					cl_standard = "CL1.2";
					have_cl_standard = true;
				}
				else if (strcmp(arg, "--help") == 0)
				{
					print_help();
					return false;
				}
				else
				{
					fprintf(stderr, "Invalid argument `%s'; see --help\n", argv[i]);
					return false;
				}
			}
			else
			{
				if (have_input_filename)
				{
					fprintf(stderr, "Only one input file may be specified\n");
					return false;
				}

				input_filename = argv[i];
				have_input_filename = true;
			}
		}

		if (!have_input_filename || !have_output_filename || !have_cl_standard)
		{
			fprintf(stderr, "A mandatory option is missing. See --help.\n");
			return false;
		}

		return true;
	}
};


class File final
{
protected:
	FILE* fp;

public:
	File(const char* path, const char* mode)
	{
		fp = fopen(path, mode);
		if (!fp)
			throw system_error(errno, generic_category(), "open file");
	}

	~File()
	{
		fclose(fp);
	}

	string read()
	{
		string output;
		char buf[10240];

		for (;;)
		{
			auto ret = fread(buf, 1, sizeof(buf), fp);
			if (ret <= 0)
			{
				if (feof(fp))
					break;

				throw runtime_error("Failed to read from file.");
			}

			output += string(buf, ret);
		}

		return output;
	}

	void write(string text)
	{
		size_t offset = 0;

		while (offset < text.size())
		{
			auto ret = fwrite(text.c_str() + offset, 1, text.size() - offset, fp);

			if (ret == 0)
				throw runtime_error("Failed to write to file.");

			offset += ret;
		}
	}
};


string platform_to_string(enum intel_platform platform)
{
	switch (platform)
	{
	case INTEL_PLATFORM_BDW:
		return string("INTEL_PLATFORM_BDW");
	case INTEL_PLATFORM_CHV:
		return string("INTEL_PLATFORM_CHV");
	case INTEL_PLATFORM_SKL:
		return string("INTEL_PLATFORM_SKL");
	case INTEL_PLATFORM_BXT:
		return string("INTEL_PLATFORM_BXT");
	case INTEL_PLATFORM_KBL:
		return string("INTEL_PLATFORM_KBL");
	case INTEL_PLATFORM_GLK:
		return string("INTEL_PLATFORM_GLK");
	case INTEL_PLATFORM_CFL:
		return string("INTEL_PLATFORM_CFL");
	case INTEL_PLATFORM_EHL:
		return string("INTEL_PLATFORM_EHL");
	case INTEL_PLATFORM_TGL:
		return string("INTEL_PLATFORM_TGL");
	case INTEL_PLATFORM_RKL:
		return string("INTEL_PLATFORM_RKL");
	case INTEL_PLATFORM_DG1:
		return string("INTEL_PLATFORM_DG1");
	default:
		throw invalid_argument("Unknown intel_platform");
	}
}


bool main_exc(Args& args)
{
	string options = "-cl-std=" + args.cl_standard;

	File input(args.input_filename.c_str(), "r");
	File output(args.output_filename.c_str(), "w");

	auto src = input.read();

	string guard = "__";
	for (char c : args.output_filename)
	{
		if ((c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_')
		{
			guard += c;
		}
		else if (c >= 'a' && c <= 'z')
		{
			guard += c - ('a' - 'A');
		}
		else if (c == '-' || c == '.')
		{
			guard += '_';
		}
	}

	output.write(
			"/* Compiled GPU binary code generated by llt_gpgpu_rt_i915_c */\n#ifndef " +
			guard + "\n#define " + guard + "\n\n");

	/* Require the user to include i915_runtime.h before s.t. we do not need to
	 * decide here if i915_compiled_program.h is in the default search path or
	 * not. */
	// output.write("#include <i915_compiled_program.h>\n\n");

	output.write("namespace CompiledGPUProgramsI915\n{\n\n");

	string program_name;

	/* basename of input file path */
	auto start = args.input_filename.rfind("/");
	if (start == string::npos)
		start = 0;
	else
		start++;

	if (start >= args.input_filename.size())
	{
		fprintf(stderr, "Invalid input file name");
		return false;
	}

	auto for_program_name = args.input_filename.substr(start);
	for_program_name = for_program_name.substr(0, for_program_name.rfind("."));
	if (for_program_name.size() < 1)
	{
		fprintf(stderr, "Invalid input file name");
		return false;
	}

	for (char c : for_program_name)
	{
		/* NOTE: C symbols must not start with a number */
		if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_')
		{
			program_name += c;
		}
		else if (c >= '0' && c <= '9')
		{
			if (program_name.size() == 0)
				program_name += '_';

			program_name += c;
		}
		else if (c == '-' || c == '.')
		{
			program_name += '_';
		}
	}

	output.write("class " + program_name +
			" final : public OCL::I915CompiledProgram\n{\nprotected:\n");

	map<enum intel_platform, unique_ptr<OCL::IGCInterface::Binary>> binaries;

	auto fmap = get_product_family_map();
	for (auto& dev : fmap)
	{
		OCL::IGCInterface igc(
				dev.first,
				dev.second.render_core_family,
				dev.second.default_timestamp_frequency);

		auto kernel_bin = igc.build(src.c_str(), options.c_str());
		auto build_log = igc.get_build_log();

		if (!kernel_bin)
			fprintf(stderr, "Failed to compile kernel:\n");

		if (build_log.size() > 0)
			fprintf(stderr, "Build log:\n%s\n", build_log.c_str());

		if (!kernel_bin)
			return false;

		auto platform = OCL::get_intel_platform(dev.first);
		if (binaries.find(platform) != binaries.end())
			throw runtime_error("Multiple binaries for same architecture");

		binaries.insert({platform, move(kernel_bin)});
	}

	/* Generate static arrays with binaries and sizes */
	/* Binary aliasing */
	map<enum intel_platform, int> bin_index_map;

	vector<const char*> bins_to_write;
	vector<size_t> sizes;

	for (auto& [platform, bin] : binaries)
	{
		auto bin_code = bin->get_bin();
		auto bin_size = bin->bin_size;

		/* Has a bit-equivalent binary already been written? - if so, use that
		 * one for this architecture. */
		bool found = false;
		for (size_t i = 0; i < bins_to_write.size(); i++)
		{
			if (sizes[i] == bin_size && memcmp(bin_code, bins_to_write[i], bin_size) == 0)
			{
				bin_index_map.insert({platform, i});
				found = true;
				break;
			}
		}

		if (found)
			continue;

		bin_index_map.insert({platform, bins_to_write.size()});
		bins_to_write.push_back(bin_code);
		sizes.push_back(bin_size);
	}


	/* Binaries declaration */
	output.write("\tstatic const char* binaries[" + to_string(bins_to_write.size()) + "];\n");

	/* Sizes declaration */
	output.write("\tstatic const size_t sizes[" + to_string(sizes.size()) + "];\n\n");

	/* Accessor */
	output.write(R"SRC(public:
	std::optional<std::pair<const char*, size_t>> get_bin(enum intel_platform platform) const override
	{
		switch (platform)
		{
)SRC");

	for (auto [platform, k] : bin_index_map)
	{

		auto k_str = to_string(k);
		output.write("\t\tcase " + platform_to_string(platform) + ":\n" +
				"\t\t\treturn std::make_pair(binaries[" + k_str +
				"], sizes[" + k_str + "]);\n\n");
	}

	output.write(R"SRC(		default:
			return std::nullopt;
		};
	}
)SRC");

	output.write("};\n\n");

	/* Binaries definition */
	output.write("const char* " + program_name + "::binaries[] = {");
	bool first = true;

	for (size_t k = 0; k < bins_to_write.size(); k++)
	{
		auto bin_code = bins_to_write[k];
		auto bin_size = sizes[k];

		if (first)
		{
			first = false;
			output.write("\n");
		}
		else
		{
			output.write(",\n\n");
		}

		for (size_t pos = 0; pos < bin_size;)
		{
			output.write("\t\"");

			for (int i = 0; i < 16 && pos < bin_size; i++, pos++)
			{
				char buf[5];
				snprintf(buf, 5, "\\x%02x", (unsigned) (unsigned char) bin_code[pos]);
				buf[4] = '\0';
				output.write(buf);
			}

			if (pos != bin_size)
				output.write("\"\n");
			else
				output.write("\"");
		}
	}

	output.write("\n};\n\n");

	/* Sizes definition */
	output.write("const size_t " + program_name + "::sizes[] = {");

	first = true;
	for (auto s : sizes)
	{
		if (first)
		{
			first = false;
			output.write("\n");
		}
		else
		{
			output.write(",\n");
		}

		output.write("\t" + to_string(s));
	};

	output.write("\n};\n");

	output.write("\n}\n#endif /* " + guard + " */\n");
	return true;
}

int main(int argc, char** argv)
{
	try
	{
		Args args;
		if (!args.parse(argc, argv))
			return EXIT_FAILURE;

		if (main_exc(args))
			return EXIT_SUCCESS;
		else
			return EXIT_FAILURE;
	}
	catch (exception& e)
	{
		fprintf(stderr, "Error: %s\n", e.what());
		return EXIT_FAILURE;
	}
}
